\chapter{Theoretischer Hintergrund}

\section{Locks, Mutex}
Im folgenden werden die Begriffe Lock und Mutex synonym verwendet.\\
Es gibt Situation in nebenläufigen Programmen, in denen sich verschiedene 
Routienen nicht gleichzeitig in bestimmten Bereichen aufhalten dürfen.\\
Locks gehören zu den am weitesten verbreiteten Mechanismen um solche kritische 
Bereiche in einem Programm zu schützen \cite{zhou}.
Möchte ein Routine $R_1$ nun in einen Bereich 
eintreten, der durch ein Lock, welches bereits von einer anderen Routine $R_0$ 
gehalten wird, geschützt ist, muss sie so lange vor dem Lock warten, bis das Lock 
von $R_0$ wieder frei gegeben wird.
\subsection{Operationen}
Auf Locks sind in der Regel die drei folgenden Operationen definiert.
\begin{itemize}
    \item Lock: Eine Routine $R$ versucht das Lock zu beanspruchen. Wird das Lock 
        von keiner Routine gehalten, wird das Lock geschlossen, so dass andere 
        Routinen es nicht schließen können, bis es von $R$ wieder frei gegeben 
        wird. Ist es nicht möglich das Lock zu beanspruchen, da es bereits von 
        einer anderen Routine gehalten wird, muss $R$ so lange von der Operation 
        warten, bis eine Beanspruchung erfolgreich ist.
    \item TryLock: TryLock unterscheidet sich von Lock dadurch, das die Routine,
        wenn es nicht möglich ist, das Lock zu beanspruchen nicht vor der 
        Operation wartet, sondern weiter ausgeführt wird, ohne das Lock geschlossen
        zu haben. Die Operation gibt außerdem zurück, ob die Beanspruchung 
        erfolgreich war.
    \item Unlock: Unlock gibt ein Lock wieder frei. Es kann nur von der Routine 
        frei gegeben werden, die es geschlossen hat.
\end{itemize}
\subsection{RW-Locks}
Neben den allgemeinen Locks gibt es noch Reader-Writer Locks. Diese haben im 
Vergleich zu den allgemeinen Locks zwei Lock und TryLock Operation, R-Lock und 
W-Lock (analog für Try-Lock). W-Lock, im folgenden einfach Lock genant funktioniert 
identisch zu Lock in den allgemeinen Locks. Bei R-Locks hingegen ist es, anders 
als bei Lock, möglich dass das Lock gleichzeitig von verschiedenen Routine gehalten wird
(oder mehrfach von der selben Routine), solange alle diese Beanspruchungen durch 
R-Lock erfolgt sind. Es ist nicht möglich ein Lock gleichzeitig durch R-Lock und 
Lock zu schließen.

\section{Deadlock} \label{Kap::Theo:Deadlocks}
Ein Deadlock ist ein Zustand in einem nebenläufigen Programm, also einem 
Programm, in dem mehrere Routinen gleichzeitig ausgeführt werden, wobei alle 
laufenden Routinen zyklisch auf die Freigabe von Ressourcen warten.
Ein solcher Deadlock kann nun entstehen, wenn all Routinen vor einem Lock warten 
müssen, wobei die Locks immer von einer anderen Routine gehalten werden.\\
Man betrachte dazu das folgende Beispiel \cite{sulzmann} mit den Locks $x$ und $y$ 
und den beiden Routinen $R_1$ und $R_2$, welches den Ablauf eines Programms 
darstellt. $acq_i(l)$ bezeichnet dabei, dass das Lock $l$ von der Routine $R_i$ 
beansprucht und $rel_i(l)$, dass $l$ von $R_i$ wieder freigegeben wird.
\begin{table}[H]
    \centering
    \begin{tabular}{ccc}
       & $R_1$        & $R_2$          \\
    1. & $acq_{1}(y)$ &                \\
    2. & $acq_{1}(x)$ &                \\
    3. & $rel_{1}(x)$ &                \\
    4. & $rel_{1}(y)$ &                \\
    5. &              & $acq_{2}(x)$ \\
    6. &              & $acq_{2}(y)$ \\
    7. &              & $rel_{2}(y)$ \\
    8. &              & $rel_{2}(x)$
    \end{tabular}
\end{table}
Da $R_1$ und $R_2$ gleichzeitig ablaufen ist es möglich, dass sich die 
Reihenfolge der einzelnen Operationen zwischen den Routinen ändert (die Reihenfolge
innerhalb einer Routine ist immer gleich). Damit ist für das Programm, welches 
zu dem obigen Ablauf geführt hat, auch folgender Ablauf möglich. 
\begin{table}[H]
    \centering
    \begin{tabular}{ccc}
       & $R_1$          & $R_2$          \\
    1. & $acq_{1}(y)$ &                \\
    5. &                & $acq_{2}(x)$ \\
    2. & $B_2-acq_{1}(x)$ &                \\
    6. &                & $B_1-acq_{2}(y)$
    \end{tabular}
\end{table}
Dabei impliziert $B_j-acq_i(l)$, dass $acq_{i}(l)$ nicht ausgeführt werden konnte,
bzw. dass die Routine $R_i$ vor dem Lock halten muss, da das Lock bereits von 
Routine $R_j$ beansprucht wird. In diesem Beispiel wartet nun $R_1$ 
darauf, dass das Lock $x$ freigegeben wird und $R_2$ wartet darauf, dass Lock 
$y$ freigegeben wird. Da nun alle Routinen warten müssen, bis ein Lock freigegeben 
wird, allerdings keine der Routinen weiter laufen kann um ein Lock zu öffnen, 
kommt es zum Stillstand. Dieser Zustand wird als zyklicher Deadlock bezeichnet.\\\\
Eine andere Situation, bei der ein Deadlock entstehen kann tritt auf, wenn 
eine Routine das selbe Lock mehrfach beansprucht, ohne es zwischendurch wieder 
frei zu geben. Dies ist sogar möglich, wenn in dem Programm zu diesem Zieitpukt
nur eine Routine aktiv ist. Ein Beispiel dafür gibt der folgende Programmablauf:
\begin{table}[H]
    \centering
    \begin{tabular}{cc}
        & $R_1$ \\
        1. & $acq_{1}(x)$ \\
        2. & $B_1-acq_1(x)$
    \end{tabular}
\end{table}
Die Routine muss dabei vor der zweiten Beanspruchung warten,
ohne dass es es die Möglichkeit gibt, dass die Routine irgendwann weiter laufen wird.
Solch ein Deadlock wird als doppeltes Locking bezeichnet.\\
\section{Deadlocks-Detection}
Deadlocks in Programmen sind Fehler, die oft den vollständige Abbruch eines 
Programmes zu Folge haben, wenn keine zusätzliche Logik zur Erkennung und Auflösung von 
Deadlocks implementiert ist. Aus diesem Grund möchte man bereits bei der 
Implementierung eines Programmes verhindern, dass ein solcher Deadlock auftreten 
kann. Unglücklicherweise kann es ohne zusätzliche Hilfsmittel schwierig sein, 
einen solchen Deadlock zu erkennen, da das Auftreten eines Deadlock von dem 
genauen zeitlichen Ablauf der verschiedenen Routinen abhängt.\\
Um dennoch Deadlocks 
erkennen zu können, können Lock-Graphen oder Lock-Bäume verwendet werden, die 
im folgenden betrachtet werden sollen.
\subsection{Lock-Graphen}
Ein Lock-Graph ist ein gerichteter Graph $G = (L, E)$. Dabei ist $L$ die Menge 
aller Locks. $E \subseteq L \times L$ ist definiert als $(l_1, l_2) \in E$ genau 
dann wenn es eine Routine $R$ gibt, auf welche $acq(l_2)$ ausgeführt wird, während sie 
bereits das Lock $l_1$ hält \cite{bensalem}. Mathematisch ausgedrückt gilt also 
\begin{align*}
    (l_1, l_2) \in E \Leftrightarrow \exists t_1, t_3\ \nexists t_2\ \exists i\ ((t_1 < t_2 < t_3) \land aqr_i(l_1)[t_1] \land rel_i(l_1)[t_2] \land  aqr_i(l_2)[t_3])
\end{align*}
wobei $aqr_i(l_1)[t_i]$ bedeutet, dass $aqr(l_1)$ zum Zeitpunkt $t_i$ auf Routine 
$i$ ausgeführt wird und equivalent für $rel_i(l_1)[t_i]$.\\
Ein Deadlock kann nun auftreten wenn es innerhalb dieses Graphen einen Kreis 
gibt. Um zu verhindern, dass ein False-Positive dadurch ausgelöst wird, dass 
alle Kanten in einem solchen Kreis aus der selben Routine kommen (wodurch kein 
Deadlock entstehen kann), können die Kanten noch zusätzlich mit einem Label 
versehen werden, welches die Routine identifiziert, durch welche die Kante in 
den Graphen eingefügt wurde. Bei dem Testen nach Zyklen muss nun beachtet 
werden, dass nicht alle Kanten in dem Kreis das selbe Label haben 
\cite{bensalem}. Es sei zusätzlich noch gesagt, dass ein Zyklus in einem 
Lockgraphen nicht immer auf ein potentielles Deadlock hinweist. Ein solcher 
Fall, bei dem die Detektion von Zyklen zu einer fälschlichen Detektion 
führt sind sogenannt Gate-Locks. Diese treten z.B. in folgender Situation
auf:
\begin{table}[H]
     \centering
     \begin{tabular}{ccc}
        & $R_1$        & $R_2$          \\
     1. & $acq_{1}(z)$ &                \\
     2. & $acq_{1}(y)$ &                \\
     3. & $acq_{1}(x)$ &                \\
     4. & $rel_{1}(x)$ &                \\
     5. & $rel_{1}(y)$ &                \\
     6. & $rel_{1}(z)$ &                \\
     7. &              & $acq_{2}(z)$ \\
     8. &              & $acq_{2}(x)$ \\
     9. &              & $acq_{2}(y)$ \\
    10. &              & $rel_{2}(y)$ \\
    11. &              & $rel_{2}(x)$ \\
    12. &              & $rel_{2}(z)$
    \end{tabular}
\end{table}
In diesem Fall bilden die Locks $x$ und $y$ in dem Lockgraphen einen Zyklus. 
Allerdings verhindert das Lock $z$, dass in diesem Fall ein tatsächliches 
Deadlock auftreten kann, da sich immer nur eine der beiden Routinen 
in dem Bereich mit den Locks $x$ und $y$ aufhalten kann.

\subsection{Lock-Bäume} \label{Kap::Theo:LockTree}
Anders als bei Lock-Graphen, speichert bei Lock-Bäumen jede Routine  
seine eigenen Abhängigkeiten. Dies bedeutet, dass der Lock-Baum $b$ der 
Routine $R$ genau dann die Kante $x\to y$ besitzt, wenn in Routine $R$ das 
Lock $y$ beansprucht wird, während in das Lock $x$ in $R$ bereits gehalten wird.\\
Im folgenden, wird ein Lock-Baum als eine Menge von Dependencies betrachtet. 
Eine solche Dependency besteht aus einem Lock $mu$ und einer Menge von Locks $hs$
($\glqq$holdingSet$\grqq$),
von denen $mu$ anhängt, für die es also eine Kante $x \to mu$ mit $x \in hs$ gibt.\\
Ein potentielles Deadlock liegt nun vor, wenn es in der Menge aller Dependencies
eine gültige, zyklische Kette gibt.\\
Ein Pfad mit $n$
Elementen ist eine gültige Kette, wenn die folgenden Eigenschaften gelten:
\begin{align}
  &\forall i, j \in \{1,...,n\}: \lnot (i = j) \rightarrow \lnot (dep_i = dep_j) \tag{\ref{Kap::Theo:LockTree}.a}
  \label{For::Theo:LockTree.a}\\
  &\forall i \in \{1,...,n\}: mu_i \in hs_{i+1} 
  \tag{\ref{Kap::Theo:LockTree}.b}
  \label{For::Theo:LockTree.b}\\
  &\forall i \in \{1,...,n\}: read(mu_i) \rightarrow 
  (\forall\ mu \in hs_{i+1}:(mu = mu_i) \to \lnot read(mu))
  \tag{\ref{Kap::Theo:LockTree}.c}
  \label{For::Theo:LockTree.c}\\
  &\forall i, j \in \{1,...,n\}: \lnot (i = j) \rightarrow 
  (\exists\ l1 \in hs_i\ \exists\ l2 \in hs_j ((l1 = l2) \rightarrow 
  (read(l1) \land read(l2)))) 
  \tag{\ref{Kap::Theo:LockTree}.d}
  \label{For::Theo:LockTree.d}
\end{align}
Dabei bezeichnet $mu_i$ den Mutex und $hs_i$ das holdingSet der $i$-ten 
Dependency in der Kette. $read(mu)$ bedeutet, dass das Locking von $mu$, welches 
in der Dependency abgebildet ist durch ein R-Lock zustande gekommen ist.\\
\eqref{For::Theo:LockTree.a} stellt sicher, dass die selbe 
Dependency nicht mehr als ein mal in der Kette auftauchen kann.  
\eqref{For::Theo:LockTree.b} besagt, dass die Dependencies tatsächlich
eine Kette bilden müssen, dass also der Mutex einer Dependency immer in dem 
HoldingSet der nächsten Dependency in dem Pfad enthalten sein muss. 
Auch wenn dies wahr ist, ist dies dennoch keine gültige Kette, wenn sowohl der
Mutex $mu_i$ als auch der Mutex $mu$ in $hs_{i+1}$, für die $mu = mu_i$ gilt, 
beides Reader-Locks sind. Dass solche Pfade ausgeschlossen werden wird durch 
\eqref{For::Theo:LockTree.c} sichergestellt. Die letzte Formel 
\eqref{For::Theo:LockTree.d} beschäftigt sich mit Gate-Locks. 
Sie besagt, dass wenn es einen Mutex gibt, 
der in den HoldingSets zweier verschiedener Dependencies in dem Pfad vor kommt, 
so müssen beide diese Mutexe Reader-Locks sein. Sind sie es nicht, handelt es 
sich um Gate-Locks, und der entsprechende Pfad kann somit nicht zu einem 
Deadlock führen. Wenn diese vier Formeln erfüllt sind, handelt es sich um eine 
gültige Kette.\\
Ein potentielles Deadlock ergibt sich nun, wenn diese Kette einen Kreis 
bildet, wenn als 
\begin{align}
  &mu_n \in hs_{1} 
  \tag{\ref{Kap::Implementation:Periodical}.e}
  \label{For::Implementation:Periodical.e}\\
  &read(mu_n) \rightarrow 
  (\forall\ mu \in hs_{1}: (mu = mu_n) \to \lnot read(mu))
  \tag{\ref{Kap::Implementation:Periodical}.f}
  \label{For::Implementation:Periodical.f}
\end{align}
gilt.\\\\
Diese Bäume haben mehrere Vorteile gegenüber Lock-Graphen. Da jede Routine seine 
eigene Datenstruktur hat, wird verhindert, dass es durch 
gleichzeitigen Zugriff verschiedener Routinen auf die selbe Datenstruktur zu 
Problemen kommet. Zudem muss die Zugehörigkeit der Abhängigkeiten zu 
verschiedenen Routinen nicht explizit gespeichert werden. Ein weiterer Vorteil 
besteht darin, dass Gate-Locks bei Lock-Bäumen, anders als bei Lock-Graphen
nicht zu False-Positives führen können.


\subsection{Doppeltes Locking}
Um doppeltes Locking zu erkennen ist es ausreichend vor der Lock-Operation 
zu überprüfen, ob das Lock bereits von der selben Routine gehalten wird, ohne 
dass es sich bei beiden Operationen um Reader-Locks handelt.


