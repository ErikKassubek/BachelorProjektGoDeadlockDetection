\chapter{Theoretischer Hintergrund}

\section{Lock/Mutex}
\textcolor{red}{What is a Lock/Mutex, war is rw-lock}\\
Im folgenden werden die Begriffe Lock und Mutex synonym verwendet. 

\section{Deadlocks} \label{Kap::Theo:Deadlocks}

Ein Deadlock ist ein Zustand in einem nebenläufigen Programm, also einem 
Programm, in denen mehrere Routinen gleichzeitig ausgeführt werden, indem alle 
laufenden Routinen zyklisch auf die Freigabe von Ressourcen warten.\\
Im großen und ganzen lassen sich Deadlocks in zwei Gruppen einteilen: 
Ressourcen-Deadlocks und Kommunikations-Deadlocks \cite{zhou}.
Im folgenden sollen jedoch nur durch Locks erzeugte Ressourcen-Deadlocks 
betrachtet werden.\\
Locks gehören zu den am weitesten verbreiteten Mechanismen um kritische 
Bereiche in einem Programm zu schützen, um also sicher zu stellen,
dass sich in einem nebenläufigen Programm immer nur maximal eine Routine in einem 
solchen kritischen Bereich aufhalten kann \cite{zhou}.
Möchte ein Routine $R_1$ nun in einen Bereich 
eintreten, der durch ein Lock, welches bereits von einem anderen Thread $R_0$ 
beansprucht wird, geschützt ist, muss sie so lange vor dem Lock warten, bis dieses 
von $R_0$ wieder frei gegeben wird.\\
Ein Deadlock kann nun entstehen, wenn all Treads vor einem solchen Lock warten 
müssen, wobei die Locks immer von einem anderen Tread gehalten werden. 
Im folgende bezeichnet $acq_i(l)$, dass das Lock $l$ von der Routine $R_i$ 
beansprucht und $rel_i(l)$, dass $l$ von $R_i$ wieder freigegeben wird. 
Man betrachte nun das folgende Beispiel \cite{sulzmann} mit den Routinen 
$R_1$ und $R_2$:
\begin{table}[H]
    \centering
    \begin{tabular}{ccc}
       & $R_1$        & $R_2$          \\
    1. & $acq_{1}(y)$ &                \\
    2. & $acq_{1}(x)$ &                \\
    3. & $rel_{1}(x)$ &                \\
    4. & $rel_{1}(y)$ &                \\
    5. &              & $acq_{2}(x)$ \\
    6. &              & $acq_{2}(y)$ \\
    7. &              & $rel_{2}(y)$ \\
    8. &              & $rel_{2}(x)$
    \end{tabular}
\end{table}
Da $R_1$ und $R_2$ gleichzeitig ablaufen ist folgender Ablauf möglich:
\begin{table}[H]
    \centering
    \begin{tabular}{ccc}
       & $R_1$          & $R_2$          \\
    1. & $acq_{1}(y)$ &                \\
    5. &                & $acq_{2}(x)$ \\
    2. & $B-acq_{1}(x)$ &                \\
    6. &                & $B-acq_{2}(y)$
    \end{tabular}
\end{table}
Dabei impliziert $B-acq_i(l)$, dass $acq_{i}(l)$ nicht ausgeführt werden konnte,
bzw. dass die Routine $R_i$ vor dem Lock halten muss, da das Lock bereits von 
einer anderen Routine beansprucht wird. In diesem Beispiel wartet nun $R_1$ 
darauf, dass das Lock $x$ geöffnet wird und $R_2$ wartet darauf, dass Lock 
$y$ geöffnet wird. Da nun alle Routinen warten müssen, bis ein Lock freigegeben 
wird, allerdings keine der Routinen weiter laufen kann um ein Lock zu öffnen, 
kommt es zum Stillstand. Dieser Zustand wird als zyklicher Deadlock bezeichnet.\\
Eine andere Situation, bei der ein Deadlock entstehen kann tritt auf, wenn 
eine Routine das selbe Lock mehrfach beansprucht, ohne es zwischendurch wieder 
frei zu geben. Dies ist sogar möglich, wenn in dem Programm zu diesem Zieitpukt
nur eine Routine aktiv ist. Ein Beispiel dafür gibt folgendes Programm:
\begin{table}[H]
    \centering
    \begin{tabular}{cc}
        & $R_1$ \\
        1. & $acq_{1}(x)$ \\
        2. & $acq_1(x)$\\
        3. & $rel_1{x}$
    \end{tabular}
\end{table}
Die Routine muss dabei vor der zweiten Beanspruchung warten,
ohne dass es es die Möglichkeit gibt, dass die Routine irgendwann weiter laufen wird.
Solch ein Deadlock wird als doppeltes Locking bezeichnet.\\
\section{Deadlocks-Detection}
Deadlocks in Programmen sind Fehler, die oft den vollständige Abbruch eines 
Programmes zu Folge haben, wenn keine zusätzliche Logik zur Erkennung und Auflösung von 
Deadlocks implementiert ist. Aus diesem Grund möchte man bereits bei der 
Implementierung eines Programmes verhindern, dass ein solcher Deadlock auftreten 
kann. Unglücklicherweise kann es ohne zusätzliche Hilfsmittel schwierig sein, 
einen solchen Deadlock zu erkennen, da das Auftreten eines Deadlock von dem 
genauen zeitlichen Ablauf der verschiedenen Routinen abhängt.\\
Um dennoch Deadlocks 
erkennen zu können, können Lock-Graphen oder Lock-Bäume verwendet werden, die 
im folgenden betrachtet werden sollen.
\subsection{Lock-Graphen}
Ein Lock-Graph ist ein gerichteter Graph $G = (L, E)$. Dabei ist $L$ die Menge 
aller Locks. $E \subseteq L \times L$ ist definiert als $(l_1, l_2) \in E$ genau 
dann wenn es eine Routine $R$ gibt, auf welche $acq(l_2)$ ausgeführt wird, während sie 
bereits das Lock $l_1$ hält \cite{bensalem}. Mathematisch ausgedrückt gilt also 
\begin{align*}
    (l_1, l_2) \in E \Leftrightarrow \exists t_1, t_3 \not\exists t_2\ ((t_1 < t_2 < t_3) \land aqr(l_1)[t_1] \land rel(l_1)[t_2] \land  aqr(l_2)[t_3])
\end{align*}
wobei $aqr(l_1)[t_i]$ bedeutet, dass $aqr(l_1)$ zum Zeitpunkt $t_i$ ausgeführt 
wird und equivalent für $rel(l_1)[t_i]$.\\
Ein Deadlock kann nun auftreten wenn es innerhalb dieses Graphen einen Kreis 
gibt. Um zu verhindern, dass ein False-Positive dadurch ausgelöst wird, dass 
alle Kanten in einem solchen Kreis aus der selben Routine kommen (wodurch kein 
Deadlock entstehen kann), können die Kanten noch zusätzlich mit einem Label 
versehen werden, welches die Routine identifiziert, durch welche die Kante in 
den Graphen eingefügt wurde. Bei dem Testen nach Zyklen muss nun beachtet 
werden, dass nicht alle Kanten in dem Kreis das selbe Label haben 
\cite{bensalem}. Es sei zusätzlich noch gesagt, dass ein Zyklus in einem 
Lockgraphen nicht immer auf ein potentielles Deadlock hinweist. Ein solcher 
Fall, bei dem die Detektion von Zyklen zu einer fälschlichen Detektion 
führt sind sogenannt Gate-Locks. Diese treten z.B. in folgender Situation
auf:
\begin{table}[H]
     \centering
     \begin{tabular}{ccc}
        & $R_1$        & $R_2$          \\
     1. & $acq_{1}(z)$ &                \\
     2. & $acq_{1}(y)$ &                \\
     3. & $acq_{1}(x)$ &                \\
     4. & $rel_{1}(x)$ &                \\
     5. & $rel_{1}(y)$ &                \\
     6. & $rel_{1}(z)$ &                \\
     7. &              & $acq_{2}(z)$ \\
     8. &              & $acq_{2}(x)$ \\
     9. &              & $acq_{2}(y)$ \\
    10. &              & $rel_{2}(y)$ \\
    11. &              & $rel_{2}(x)$ \\
    12. &              & $rel_{2}(z)$
    \end{tabular}
\end{table}
In diesem Fall bilden die Locks $x$ und $y$ in dem Lockgraphen einen Zyklus. 
Allerdings verhindert das Lock $z$, dass in diesem Fall ein tatsächliches 
Deadlock auftreten kann, da sich immer nur eine der beiden Routinen 
in dem Bereich mit den Locks $x$ und $y$ aufhalten kann.
\subsection{Lock-Bäume} \label{Kap::Theo:LockTree}
\textcolor{red}{umscheiben, wie funktionier detektion}
Anders als bei Lock-Graphen, speichert bei Lock-Bäumen jede Routine  
seine eigenen Abhängigkeiten. Dies bedeutet, dass der Lock-Baum $b$ der 
Routine $R$ genau dann die Kante $x->y$ besitzt, wenn in Routine $R$ das 
Lock $y$ beansprucht wird, während in das Lock $x$ in $R$ bereits gehalten wird.\\
Diese Bäume haben mehrere Vorteile gegenüber Lock-Graphen. Da jede Routine seine 
eigene Datenstruktur hat, wird verhindert, dass es durch 
gleichzeitigen Zugriff verschiedener Routinen auf die selbe Datenstruktur zu 
Problemen kommet. Zudem muss die Zugehörigkeit der Abhängigkeiten zu 
verschiedenen Routinen nicht explizit gespeichert werden. Ein weiterer Vorteil 
besteht darin, dass Gate-Locks bei Lock-Bäumen, anders als bei Lock-Graphen
nicht zu False-Positives führen können. 


\textcolor{red}{an anderen text anpassen, hs usw. genauer erklären, dependencies
erklären}
Ein Pfad mit $n$
Elementen ist eine gültige Kette, wenn die folgenden Eigenschaften gelten:
\begin{align}
  &\forall i, j \in \{1,...,n\}: \lnot (i = j) \rightarrow \lnot (dep_i = dep_j \lor dep_i.mu = 
  dep_j.mu) \tag{\ref{Kap::Theo:LockTree}.a}
  \label{For::Theo:LockTree.a}\\
  &\forall i \in \{1,...,n\}: mu_i \in hs_{i+1} 
  \tag{\ref{Kap::Theo:LockTree}.b}
  \label{For::Theo:LockTree.b}\\
  &\forall i \in \{1,...,n\}: read(mu_i) \rightarrow 
  (\forall\ mu \in hs_{i+1}:(mu = mu_i) \to \lnot read(mu))
  \tag{\ref{Kap::Theo:LockTree}.c}
  \label{For::Theo:LockTree.c}\\
  &\forall i, j \in \{1,...,n\}: \lnot (i = j) \rightarrow 
  (\exists\ l1 \in hs_i\ \exists\ l2 \in hs_j ((l1 = l2) \rightarrow 
  (read(l1) \land read(l2)))) 
  \tag{\ref{Kap::Theo:LockTree}.d}
  \label{For::Theo:LockTree.d}
\end{align}
Dabei bezeichnet $mu_i$ den Mutex und $hs_i$ das holdingSet der $i$-ten 
Dependency in der Kette. $read(mu)$ bedeutet, dass das Locking von $mu$, welches 
in der Dependency abgebildet ist durch ein R-Lock zustande gekommen ist.\\
Formel \ref{For::Theo:LockTree.a} stellt sicher, dass die selbe 
Dependency nicht mehr als ein mal in der Kette auftauchen kann. Formel 
\ref{For::Theo:LockTree.b} besagt, dass die Dependencies tatsächlich
eine Kette bilden müssen, dass also der Mutex einer Dependency immer in dem 
HoldingSet der nächsten Dependency in dem Pfad enthalten sein muss. 
Auch wenn dies wahr ist, ist dies dennoch keine gültige Kette, wenn sowohl der
Mutex $mu_i$ als auch der Mutex $mu$ in $hs_{i+1}$, für die $mu = mu_i$ gilt 
beides Reader-Locks sind. Dass solche Pfade ausgeschlossen werden wird durch 
Formel \ref{For::Theo:LockTree.c} sichergestellt. Die letzte Formel 
\ref{For::Theo:LockTree.d} beschäftigt sich mit Gate-Locks. 
Sie besagt, dass wenn es einen Mutex gibt, 
der in den HoldingSets zweier verschiedener Dependencies in dem Pfad vor kommt, 
so müssen beide diese Mutexe Reader-Locks sein. Sind sie es nicht, handelt es 
sich um Gate-Locks, und der entsprechende Pfad kann somit nicht zu einem 
Deadlock führen. Wenn diese vier Formeln erfüllt sind, handelt es sich um eine 
gültige Kette.\\
Ein potentielles Deadlock ergibt sich nun, wenn diese Kette einen Kreis 
bildet, wenn als 
\begin{align}
  &mu_n \in hs_{1} 
  \tag{\ref{Kap::Implementation:Periodical}.e}
  \label{For::Implementation:Periodical.e}\\
  &read(mu_n) \rightarrow 
  (\forall\ mu \in hs_{1}: (mu = mu_n) \to \lnot read(mu))
  \tag{\ref{Kap::Implementation:Periodical}.f}
  \label{For::Implementation:Periodical.f}
\end{align}
gilt.


%\begin{figure}[H]
%    \lstinputlisting{code/review_working_1.go}
%\end{figure}
%\begin{figure}[H]
%    \lstinputlisting{code/review_rekursive_1.go}
%\end{figure}
%\begin{figure}[H]
%    \lstinputlisting{code/review_guardLock.go}
%\end{figure}
