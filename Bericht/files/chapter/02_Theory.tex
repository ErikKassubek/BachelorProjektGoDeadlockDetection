\chapter{Theoretischer Hintergrund}

\section{Deadlocks} \label{Kap::Theo:Deadlocks}

Ein Deadlock ist ein Zustand in einem nebenläufigen Programm, indem alle laufenden Tread zyklisch auf die Freigabe von Ressourcen warten.\\
Im großen und ganzen lassen sich Deadlocks in zwei Gruppen einteilen: Ressourcen-Deadlocks und Kommunikations-Deadlocks \cite{zhou}.
Im folgenden sollen jedoch nur durch Locks erzeugte Ressourcen-Deadlocks betrachtet werden.\\
Locks gehören zu den am weitesten verbreiteten Mechanismen um sicher zu stellen, dass sich in einem nebenläufigen Programm immer nur ein Thread in einem kritischen Bereich aufhalten kann \cite*{zhou}, bzw.
dass immer nur maximal ein Tread gleichzeitig auf eine gemeinsame Resource, wie 
z.B. eine Variable zugreifen kann. Möchte ein Thread $T_1$ nun in einen Bereich eintreten, der durch ein Lock, welches bereits von einem anderen Thread $T_0$ beansprucht wird, geschützt ist, muss es so lange vor dem Lock warten, bis dieses von $T_0$ wieder frei gegeben wird.\\
Ein Deadlock kann nun entstehen, wenn all Treads vor einem solchen Lock warten müssen, wobei die Locks immer von einem anderen Tread gehalten werden. Im folgende bezeichnet $acq_i(l)$, dass das Lock $l$ von Prozess $T_i$ beansprucht und $rel_i(l)$, dass $l$ von $T_i$ wieder freigegeben wird. Man betrachte nun das folgende Beispiel \cite{sulzmann} mit den Treads $T_1$ und $T_2$:
\begin{table}[H]
    \centering
    \begin{tabular}{ccc}
       & $T_1$        & $T_2$          \\
    1. & $acq_{1}(y)$ &                \\
    2. & $acq_{1}(x)$ &                \\
    3. & $rel_{1}(x)$ &                \\
    4. & $rel_{1}(y)$ &                \\
    5. &              & $acq_{2}(x)$ \\
    6. &              & $acq_{2}(y)$ \\
    7. &              & $rel_{2}(y)$ \\
    8. &              & $rel_{2}(x)$
    \end{tabular}
\end{table}
Da $T_1$ und $T_2$ gleichzeitig ablaufen ist folgender Ablauf möglich:
\begin{table}[H]
    \centering
    \begin{tabular}{ccc}
       & $T_1$          & $T_2$          \\
    1. & $acq_{1}(y)$ &                \\
    5. &                & $acq_{2}(x)$ \\
    2. & $B-acq_{1}(x)$ &                \\
    6. &                & $B-acq_{2}(y)$
    \end{tabular}
\end{table}
Dabei impliziert $B-acq_i(l)$, dass $acq_{i}(l)$ nicht ausgeführt werden konnte, bzw. dass der Thread $T_i$ vor dem Lock halten muss, da das Lock bereits von einem anderen Tread beansprucht wird. In diesem Beispiel wartet nun $T_1$ darauf, dass das Lock $x$ geöffnet wird und $T_2$ wartet darauf, dass Lock $y$ geöffnet wird. Da nun aller Thread warten müssen, bis ein Lock freigegeben wird, allerdings keiner der Threads weiter laufen kann um ein Lock zu öffnen, kommt es zum Stillstand. Dieser Zustand wird als Deadlock bezeichnet.
\section{Deadlocks-Detection}
Deadlocks in Programmen sind Fehler, die oft den vollständige Abbruch eines Programmes zu Folge haben, wenn keine zusätzliche Routine zur Auflösung von Deadlocks implementiert ist. Aus diesem Grund möchte man bereits bei der Implementierung eines Programmes verhindern, dass ein solcher Deadlock auftreten kann. Unglücklicherweise kann es ohne zusätzliche Hilfsmittel schwierig sein, einen solchen Deadlock zu erkennen, da das Auftreten eines Deadlock von dem genauen Ablauf der verschiedenen Threads abhängt.\\ Um dennoch Deadlocks detektieren zu können, können Lock-Graphen oder Lock-Bäume verwendet werden.
\subsection{Lock-Graphen}
Ein Lock-Graph ist ein gerichteter Graph $G = (L, E)$, Dabei ist $L$ die Menge aller Locks $E \subseteq L \times L$ ist definiert als $(l_1, l_2) \in E$ genau dann wenn es einen Tread $T$ gibt, welcher $acq(l_2)$ ausgeführt, während er bereits das Lock $l_1$ hält \cite{bensalem}. Mathematisch ausgedrückt gilt also 
\begin{align*}
    (l_1, l_2) \in E \Leftrightarrow \exists t_1, t_3 \not\exists t_2\ ((t_1 < t_2 < t_3) \land aqr(l_1)[t_1] \land rel(l_1)[t_2] \land  aqr(l_2)[t_3])
\end{align*}
wobei $aqr(l_1)[t_i]$ bedeutet, dass $aqr(l_1)$ zum Zeitpunkt $t_i$ ausgeführt wird und equivalent für $rel(l_1)[t_i]$.\\
Ein Deadlock kann nun auftreten wenn es innerhalb dieses Graphen einen Kreis gibt. Um zu verhindern, dass ein false positive dadurch ausgelöst wird, dass alle Kanten in einem solchen Kreis aus dem selben Thread kommen (wodurch kein Deadlock entstehen kann), können die Kanten noch zusätzlich mit einem Label versehen werden, welche den Thread identifiziert, durch welchen die Kante in den Graphen eingefügt wurde. Bei dem Testen nach Zyklen muss nun beachtet werden, dass nicht alle Kanten in dem Kreis das selbe Label haben \cite{bensalem}. 
\subsection{Lock-Bäume }
Die Detektion von Deadlocks mit Hilfe von Lock-Bäumen besteht darin, den 
Verlauf von Lock Befehlen als Lock-Bäume zu speichern, wobei jeder Thread 
einen eigenen Baum erzeugt. Neben dem jeweiligen Baum hat jeder Thread 
zusätzlich einen Knoten in diesem Baum als $current$ Knoten.
Die Bäume werden folgendermaßen aufgebaut. Eine Lock Operation erzeugt einen 
neuen Knoten als Kind des $current$-Knoten, solange das Lock nicht vorher 
bereits in diesem Thread aufgetaucht ist. Dieser neue Knoten wird nun als 
$current$ Knoten gesetzt. Sollte das Lock bereits betrachtet worden sein und 
der Knoten, der dieses Lock repräsentiert ist ein Nachfolger von $current$, so 
wird $current$ auf diesen Nachfolgeknoten gesetzt. Wird ein Lock freigegeben,
und nicht anderweitig von dem Thread gehalten, wird der aktuelle Vorgänger des 
$current$ Knoten zu dem neuen $current$ Knoten~\cite{havelund}.\\
Nachdem das Programm abgeschlossen wurde werden die erzeugten Bäume paarweise 
miteinander verglichen. Man betrachte die Bäume $t_1, t_2$. Man betrachte 
alle Knoten $n_1$ in $t_1$ und alle Knoten $n_2$ in $t_2$ wenn $n_2$ das selbe 
Lock repräsentiert wie $n_1$. Es wird nun überprüft, dass kein Lock unter $n_1$
in $t_1$ in $t_2$ über $n_2$ ist. Sollte dies der Fall sein, ist dies ein Zeichen 
für ein mögliches Deadlock. Um zu verhindern, dass Deadlocks, die durch ein 
anderes Lock unmöglich gemacht werden fälschlicherweise detektiert werden,
werden Knoten in $t_2$ markiert, sobald sie betrachtet wurden. Knoten unterhalb
markierter Knoten werden nicht betrachtet, bis die Markierung wieder entfernt wird,
nachdem alle entsprechenden Knoten betrachtet wurde~\cite{havelund}.
Anders als in Lock-Graphen können Bäume nur Deadlocks-Erkennen, die durch das 
zyklische Warten von zwei Threads entstehen. Sobald drei oder mehr Thread beteiligt
sind, können solche Deadlocks nicht mehr erkannt werden.



\subsection{UNDEAD}
\textcolor{red}{Funktionsweise UNDEAD}
