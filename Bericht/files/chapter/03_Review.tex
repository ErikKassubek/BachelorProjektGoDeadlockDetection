\chapter{Review bestehender Tools}
Im folgenden soll eine Software zur Erkennung von Deadlocks analysiert werden.
Dazu wird die Software ``sasha-s/go-deadlock`` \cite{sasha-s}, veröffentlicht 
auf Github, betrachtet.\\
Dieses verwendet Drop-In Replacements für die, in go standardmäßig 
implementierten, sync.Mutex Locks. Diese führen sowohl das eigentliche 
Locking aus und können, beim Durchlaufen des Programms Situationen erkennen, 
die zu einem Deadlock führen können. Dabei werden sowohl ein allgemeines Lock 
als auch Readers–writer-locks implementiert. Dies wirkt sich allerdings nur auf
die Anwendung des eigentlichen Lockings aus, nicht aber auf die Detection von 
Deadlocks. Aus diesem Grund wird hierauf im folgenden nicht weiter eingegangen, 
und die Methoden für die Detection von Deadlocks bezieht sich sowohl auf die
allgemeinen als auch die Readers–writer Locks.\\
Für die Erkennung werden drei verschiedene Methoden angewendet, die im folgenden
betrachtet werden sollen.

\section{Rekursives Locking}
Unter rekursiven Locking versteht man, dass ein Lock von dem selben Thread 
mehrfach geschlossen wird, ohne zwischen diesen Schließungen wieder geöffnet zu
werden. Ein Beispiel dazu ist das folgende Programm:
\begin{figure}[H]
    \lstinputlisting{code/review_rekursive_1.go}
\end{figure}
Hierbei kann es schon, wie in dem Beispielcode gezeigt, bei nur einem Thread
zu einem Deadlock kommen. Die Funktion beansprucht das Lock $mu$ in Zeile $3$ 
für sich. In Zeile 4 versucht sie erneut das Lock $x$ zu beanspruchen. Da dieses
aber schon in Zeile 3 beansprucht wurde, muss das Programm vor Zeile 4 warten, 
bis $mu$ wieder freigegeben wird. Da dadurch aber die Freigabe in Zeile 3 
niemals erreicht werden kann wartet das Programm für immer, befindet sich also 
in einem Deadlock.\\
Um solche Situation zu erkennen speichert das Programm eine Liste $l.cur$ mit 
allen momentan gehaltenen 
Locks. Dabei wird neben der Information, welches Lock gehalten wird auch 
gespeichert, von welchem Thread das Lock gehalten wird. Wird nun ein Lock neu 
beansprucht, überprüft 
das Programm, ob dieses Lock mit dem Thread, der das Lock beanspruchen möchte 
bereits in der Liste gehalten Locks auftaucht. Ist dies der Fall, dann nimmt das
Programm an, dass es sich hierbei um ein mögliches Deadlock handelt und führt 
entsprechende Schritte aus, um den Nutzer zu warnen. Wird ein Lock wieder frei
gegeben, wird der entsprechende Eintrag aus $l.loc$ entfernt.

\section{Inkonsistentes Locking} \label{Kap::Rev:Inconsistent}
Mit dieser Methode werden möchte Deadlocks gefunden, die dadurch entstehen,
dass alle Threads zyklisch auf die Freigabe eines Locks warten, welches von 
einem anderen Thread gehalten wird. ein Beispiel dafür kann in folgender Funktion
gesehen werden:
\begin{figure}[H]
    \lstinputlisting{code/review_working_1.go}
\end{figure}
Dieses Beispiel entspricht dem in Kap. \ref*{Kap::Theo:Deadlocks} beschreiben 
Beispiel.\\
Die Detection funktioniert über einen Lockgraphen. Dieser wird über ein 
Dictionary gehandhabt. Wird ein neuer neues Lock $p$ beanspruchen, so wird für 
jedes Lock $b$ , welches bereits gehalten wird ein  
neuer Eintrag $beforeAfter\{b, p\}$ in das Dictionary $l.order$ hinzugefügt. 
Der Key gibt somit die beiden Locks an und speichert auch, welches der Beiden Locks
zuerst beansprucht wurde. Die Werte, die dem Key zugeordnet sind, beinhalten 
Information darüber, über welche Funktion, bzw. Routine das Lock beansprucht wurde.
Um zu überprüfen ob ein neues Lock zu einem Deadlock führen kann, wird überprüft,
ob $l.order$ einen Key $beforeAfter\{p, b\}$ besitzt, der die beiden Locks somit in 
umgekehrter Reihenfolge enthält. Existiert solch ein Key, bedeutet dies einen 
Loop aus zwei Kanten im Lockgraphen und somit einen möglichen Deadlock. 
Dies bedeutet aber auch, dass das Programm nicht in der Lage ist, ein Kreis 
in einem Lock-Graphen zu finden, wenn dieser aus drei oder mehr Kanten besteht.
Soche Situationen können aber dennoch zu Deadlocks führen. Ein Beispiel dafür 
ist die folgende Funktion:
\begin{figure}[H]
    \lstinputlisting{code/review_3_edge_loop.go}
\end{figure}
Führen die drei Routinen jeweils ihre erste Zeile gleichzeitig aus, muss jede 
Routine vor ihrer zweiten Zeile warten und es kommt zu einem Deadlock. Da diese
Konstellation in einem Lockgraphen aber zu einem Kreis mit einer Länge von drei 
Kanten führen würde, kann das Programm den möglichen Deadlock nicht erkennen.\\
Ein weiteres Problem besteht darin, dass das Programm Einträge aus $l.order$ nicht 
löscht, wenn ein Lock wieder frei gegeben wird. Sie werden nur entfernt, wenn 
das Dictionary eine bestimmte Größe überschreitet. Dies kann zu false-positives
führen. Ein Beispiel dazu wäre die folgende Funktion:  
\begin{figure}[H]
    \lstinputlisting{code/review_noDeletion.go}
\end{figure}
Es ist sehr einfach zu sehen, dass es in dieser Funktion nicht zu einem Deadlock 
kommen kann. Dennoch zeigt das Programm einen möglichen Deadlock an, da die 
Information über die Locks $x$ und $y$ aus Zeile $7-8$ in Zeile $10-11$ immer 
noch vorhanden ist, obwohl die beiden Locks in jedem Fall wieder freigegeben
werden, bevor Zeile $10$ erreicht wird.



\section{Timeout}
Neben diesen beiden Methoden, die vorausschauend nach möglichen Deadlocks 
Ausschau halten, versucht das Programm auch mit Timeouts um zu überprüfen ob 
sich das Programm bereits in einem Deadlock befindet. Möchte ein Thread ein 
Deadlock beanspruchen wird vorher eine go routine mit einem Counter gestartet.
Sollte die Inanspruchnahme des Locks innerhalb der vorgegebenen Zeit 
(default: 30s) gelingen, wird die go routine beendet. Sollte es nicht gelingen,
nimmt das Programm nach der festgelegten Zeit an, dass es zu einem Deadlock 
gekommen ist und gibt eine entsprechende Nachricht aus.\\
Diese Methode kann
durchaus nützlich sein, um über Deadlocks informiert zu werden. Allerdings führt
sie sehr leicht zu false-positives, wenn die Abarbeitung anderer Routinen und 
damit die Freigabe des Locks länger Dauer, als die festgelegte Timeout Zeit.
Im folgenden Beispiel wird dies deutlich:
\begin{figure}[H]
    \lstinputlisting{code/review_timeout_falsePositive.go}
\end{figure}
Der Chanel finished wird lediglich verwendet um zu verhindern, dass das Programm 
beendet wird, bevor die gol Routinen durchlaufen wurden. Er ist für die Deadlock
Analyse also irrelevant. Das Programm startet zwei go-Routinen, die beide das 
selbe Lock $x$ verwenden. Durch den time.Sleep(2 * time.Second) command wird 
sichergestellt, dass die erste go Routine zuerst auf das Lock zugreift. 
Dass Lock in Routine 2 muss also warten, bis es in Routine 1 wieder freigegeben
wird. Dies geschieht in etwa $38 s$ nachdem die zweite Routine mit dem warten 
auf die Freigabe von $x$ beginnt. Da dies länger ist als die standardmäßig
festgelegte maximale Wartezeit von $30 s$ nimmt das Programm an, es sei in einen 
Deadlock gekommen, obwohl kein Solcher vorliegt, und auch kein Deadlock möglich 
ist.

\section{False Negatives}
Neben den bereits in den vorherigen Abschnitten betrachteten Fällen, bei denen 
ein möglicher Deadlock nicht erkannt wurde, gibt es noch andere Fälle, bei denen
dies der Fall ist. Ein Fall,
bei dem ein Deadlock auftreten könnte, welcher von dem Programm aber nicht erkannt
wird, entsteht bei verschachtelten Routinen. Dabei erzeugt eine go-Routine eine 
weitere.
\begin{figure}[H]
    \lstinputlisting{code/review_nested.go}
\end{figure}
Diese Funktion ist bezüglich ihres Ablaufs identisch zu der Funktion 
circularLocking in Kapitel \ref*{Kap::Rev:Inconsistent}. Dennoch ist es dem 
Programm aufgrund der Verschachtelten go-Routine nicht möglich, den möglichen 
Deadlock zu erkennen. 
