\chapter{Analyse von deadlock-go und Vergleich mit 
    go-deadlock (sasha-s)}
Im Folgenden soll der in \ref{Chap::Implementation} beschriebene und in 
\cite{implementation} implementierte Detektor analysiert und mit dem in 
\ref{Chap::Review:go-deadlock} betrachteten Detektor verglichen
werden. Um Verwechslungen zwischen den beiden relativ ähnlichen Namen zu vermeiden,
wird dieser im folgenden nach dem Besitzer des Git-Hub Repositories als sasha-s
bezeichnet.\\
Für den Vergleich werden verschiedene Beispiel-Programme betrachtet, die in 
\cite{examples} implementiert sind. Diese bestehen zum einen aus verschiedenen 
Standartsituationen, wie zyklisches Locking aus zwei oder drei Locks, 
Double-Locking, Deadlock, die auf 
Grund von Guardlocks nicht auftreten können und Deadlocks in verschachtelte Routinen. 
Zum anderen werden noch weiter 
Programme betrachtet, die näher an Programmen sind, die in der tatsächlichen 
Programmentwicklung auftreten können. Diese werden aus \cite{gobench} übernommen.
Da keines der beiden Programm in der Lage is potentielle Communication-Deadlocks
zu erkennen, wurde die Menge der Beispielprogramme auf die Menge der Programme 
mit Resourcen-Deadlocks beschränkt. Da deadlock-go in sein momentanen Zustand 
keine RWLocks implementiert wurden Programme, dies solche enthalten entsprechend
angepasst.
\section{Erkennung von Deadlocks}

Man betrachte zuerst die Standartprobleme. Ein potenzielles Deadlock, welches 
durch das zyklische Locking von zwei Deadlocks auftritt kann durch beide Tools
erkannt werden. Sobald diese Zyklen allerdings eine Länge von 3 oder mehr 
erreichen, werden diese durch sasha-s nicht mehr erkannt. Deadlock-go 
hingegen ist in der Lage auch diese potentiellen Deadlocks zu erkennen.\\
Auch bei Deadlocks, in denen zwar zyklisches Locking auftritt, welche aber 
auf Grund von Guardlocks nicht zu einem tatsächlich Deadlock führen können,
schneidet deadlock-go besser ab. Da dieses mit Lock-Bäumen und nicht mit 
Lockgraphen implementiert ist, wird in diesem Fall kein potentielles Deadlock 
ausgegeben. sasha-s hingegen erkennt nicht, dass solch ein Deadlock nicht 
auftreten kann und gibt somit ein false-positive potentielles Deadlock aus.\\ 
sasha-s ist standardmäßig dazu in  der Lage doppeltes Locking zu erkennen.
Bei deadlock-go hängt die Erkennung solcher Deadlocks von den Optionen ab.
UNDEAD, auf dem die Implementierung basiert ist nicht in der Lage, doppeltes 
Locking zu erkennen. Da diese aber dennoch auftreten können, wurde diese 
Implementierung um eine solche Erkennung erweitert. Diese kann allerdings 
in den Optionen deaktiviert werden. In diesem Fall ist deadlock-go nicht in 
der Lage, solche Deadlocks zu erkennen. \\ 
Bei verschachtelten Routinen wie in \ref{Kap::Rev:Cyclic} beschrieben ist 
keines der Tools in der Lage das potentielle Deadlock zu erkennen.\\\\ 
Im folgenden sollen nun die Beispielprogramme aus \cite{implementation} 
betrachtet werden. Für deadlock-go wurden dabei alle Optionen aktiviert, um ein 
optimales Detektionsergebnis zu erhalten.
Die folgende Tabele gibt für jedes Programm neben den
Typ des potentiellen Deadlock an, ob es von den Detektoren erkannt wurde. 
\begin{table}[H]
\centering
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{id} & \textbf{Typ} & \textbf{deadlock-go} & \textbf{sasha-s} \\ \hline
Cockroach584 & Doppeltes Locking & Ja & Ja \\ \hline
Cockroach9935 & Doppeltes Locking & Ja & Ja \\ \hline
Cockroach3710 & Doppeltes Locking & Ja & Ja \\ \hline
Cockroach6181 & Doppeltes Locking & Ja & Ja \\ \hline
Cockroach7504 & Zyklische Locking & Ja & Nein \\ \hline
Cockroach10214 & Zyklische Locking & Ja & Ja \\ \hline
Etcd5509 & Doppeltes Locking & Ja & Nein \\ \hline
Etcd6708 & Doppeltes Locking & Ja & Ja \\ \hline
Etcd10492 & Doppeltes Locking & Ja & Ja \\ \hline
Grep3017 & Doppeltes Locking & Ja & Ja \\ \hline
Hugo3251 & Zyklisches Locking & Ja & Ja \\ \hline
Kubernetes13135 & Zyklisches Locking & Ja & Ja \\ \hline
Kubernetes62464 & Zyklisches Locking & Ja & Ja \\ \hline
Kubernetes30872 & Zyklisches Locking & Ja & Ja \\ \hline
Moby4951 & Zyklisches Locking & Ja & Ja \\ \hline
Moby7559 & Doppeltes Locking & Ja & Ja \\ \hline
Moby17176 & Doppeltes Locking & Ja & Ja \\ \hline
Moby36114 & Doppeltes Locking & Ja & Ja \\ \hline
Syncthing4829 & Doppeltes Locking & Ja & Ja \\ \hline
\end{tabular}
\end{table}
Wenn man diese Beispiele betrachtet sieht man, dass beide Programme einen
sehr guten Job darin machen, potentielle Deadlocks zu erkennen. 
Deadlock-go erkennt in diesen Beispielprogrammen alle potentiellen
Deadlocks, wärend sasha-s bei zwei der Probleme fälschlicherweise 
kein Problem findet.