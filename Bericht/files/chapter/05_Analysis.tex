\chapter{Analyse von Deadlock-Go und Vergleich mit 
    go-deadlock (sasha-s)}
Im Folgenden soll der in \ref{Kap::Implementaion} beschriebene und in 
\cite{implementation} implementierte Detektor \glqq Deadlock-Go\grqq\ analysiert 
und mit dem in 
\ref{Chap::Review:go-deadlock} betrachteten Detektor \glqq go-deadlock\grqq\ verglichen
werden. Um Verwechslungen zwischen den beiden relativ ähnlichen Namen zu vermeiden,
wird dieser im folgenden nach dem Besitzer des Git-Hub Repositories als sasha-s
bezeichnet.\\
Für den Vergleich werden verschiedene Beispiel-Programme betrachtet, die in 
\cite{examples} implementiert sind. Diese bestehen zum einen aus verschiedenen 
Standartsituationen, zum anderen auf Programmen, die aus tatsächlichen
Programmen übernommen wurden. Diese werden aus Gobench \cite{gobench}, einer 
Benchmark Suite für Parallelitätsfehler in Go ausgewählt.
\section{Funktionale Analyse}
Man betrachte die Programme zuerst funktional, d.h. man überprüft, ob sie zu den 
gewünschten Ergebnissen führen.\\
Man betrachte zuerst die Standardsituationen. In der folgenden Tabelle 
\ref{Tab::Analyse:Functional.Standart} sind die 
betrachteten Situation beschrieben. Dazu wird für jede Situation eine kurze 
Beschreibung angegeben und dann überprüft, ob die beiden Detektoren in der Lage 
sind diese korrekt zu klassifizieren, d.h. ein Warnung über einen Deadlock auszugeben
wenn ein solcher vorliegt, und keine Warnung zu geben, wenn kein Deadlock auftreten
kann.\\\\
Ein potenzielles Deadlock, welches 
durch das zyklische Locking von zwei Deadlocks auftritt kann durch beide Tools
erkannt werden (1.1). Ebenso erkenne beide, dass kein Deadlock vorliegt, wenn das 
Locking von mehreren Locks nicht zyklisch verläuft (1.2).
Sobald diese Zyklen allerdings eine Länge von 3 oder mehr 
erreichen, werden diese durch sasha-s nicht mehr erkannt, da dieser 
Detektor nur nach Loops der Länge zwei sucht (2). Deadlock-Go 
hingegen ist in der Lage auch diese potentiellen Deadlocks zu erkennen.\\
Auch bei Deadlocks, in denen zwar zyklisches Locking auftritt, welche aber 
auf Grund von Gate-Locks nicht zu einem tatsächlich Deadlock führen können,
schneidet Deadlock-Go besser ab (3). Da dieser mit Lock-Bäumen und nicht mit einem
Lock-Graphen implementiert ist, wird in diesem Fall kein potentielles Deadlock 
ausgegeben. sasha-s hingegen erkennt nicht, dass solch ein Deadlock nicht 
auftreten kann und gibt somit eine false-positive Mitteilung über ein potentielles 
Deadlock aus.\\ 
sasha-s ist standardmäßig dazu in  der Lage doppeltes Locking zu erkennen.
Bei Deadlock-Go hängt die Erkennung solcher Deadlocks von den Optionen ab.
UNDEAD, auf dem die Implementierung basiert ist nicht in der Lage, doppeltes 
Locking zu erkennen. Da diese aber dennoch auftreten können, wurde diese 
Implementierung um eine solche Erkennung erweitert. Diese kann allerdings 
in den Optionen deaktiviert werden. Standardmäßig ist Deadlock-Go also auch in 
der Lage solche Deadlocks durch doppeltes Locking zu erkennen (5). \\ 
Bei verschachtelten Routinen wie in \ref{Kap::Rev:Cyclic} beschrieben ist 
keines der Tools in der Lage das potentielle Deadlock zu erkennen (4).\\
Für tatsächlich auftretende Deadlocks, welche durch zyklisches Locking auftreten 
sind beide Detektoren in der Lage, solche Situationen zu erkennen (6).\\\\
Für sasha-s sind keine Try-Lock-Operationen implementiert. Aus diesem Grund 
können potentielle Deadlocks, die solche Try-Lock Operationen besitzen nicht 
wirklich erkannt werden.\\Deadlock-Go besitzt eine Implementierung von Try-Lock-
Operationen. Doppeltes Locking kann für Try-Lock erkannt werden, sowohl wenn 
es auch bei ein Try-Lock zu doppeltem Locking kommt (7.1), als auch wenn es
durch die Try-Lock-Operation doppeltes Locking verhindert wird (7.2). Deadlock-Go
ist nicht in der Lage Deadlocks zu erkennen, wenn dieses durch zyklisches Locking 
auftritt, wobei der Zyklus ein Try-Lock enthält. Es wird kein potentieller
Deadlock erkannt, unabhängig davon, ob der Zyklus mit dem Try-Lock zu einem  
Deadlock führen kann oder nicht (8).


\begin{table}[H]
\centering
\begin{tabular}{|l|l|l|l|}
    \hline
    \textbf{ID} & \textbf{Typ} & \textbf{Deadlock-Go} & \textbf{sasha-s} \\ \hline
    1.1 & Potentielles Deadlock durch zyklisches Locking von zwei Locks & Ja & Ja \\ \hline
    1.2 & Kein Potentielles Deadlock, da die Locks nicht zyklisch sind & Ja & Ja \\ \hline
    2 & Potentielles Deadlock durch zyklisches Locking von drei Locks & Ja & Nein \\ \hline
    3 & \makecell[l]{Zyklisches Locking welches aber durch Gate-Locks nicht\\zu einem Deadlock führen kann} & Ja & Nein \\ \hline
    4 & \makecell[l]{Potentielles Deadlock, welches durch Verschachtlung mehrerer\\Routinen (fork/join) verschleiert wird} & Nein & Nein \\ \hline
    5 & Deadlock durch doppeltes Locken & Ja & Ja \\ \hline
    6.1 & \makecell[l]{Tatsächliches Deadlock durch zyklisches Locking von Locks\\in zwei Routinen} & Ja & Ja \\ \hline
    6.2 & \makecell[l]{Tatsächliches Deadlock durch zyklisches Locking von Locks\\in drei Routinen} & Ja & Ja \\ \hline
    7.1 & Doppeltes Locking mit TryLock (TryLock $\to$ Lock) & Ja & Nein$^*$ \\ \hline
    7.2 & Kein Doppeltes Locking mit TryLock (Lock $\to$ TryLock) & Ja & Nein$^*$\\ \hline
    8.1 & Deadlock durch zyklisches Locking mit TryLock & Nein &Nein$^*$ \\ \hline
    8.2 & \makecell[l]{Zyklisches Locking, welches durch TryLock nicht zu\\einem Deadlock führt} & Ja &Nein$^*$ \\ \hline   
    9.1 & \makecell[l]{Potentielles Deadlock mit RW-Lock in zwei Routinen\\(R1: x.RLock $\to$ y.Lock, R2: y.Lock $\to$ x.Lock)} & Ja & Ja \\ \hline
    9.2 & \makecell[l]{Potentielles Deadlock mit RW-Lock in zwei Routinen\\(R1: x.RLock $\to$ y.Lock, R2: y.RLock $\to$ x.Lock)} & Ja & Ja \\ \hline
    9.3 & \makecell[l]{Kein potentielles Deadlock mit RW-Lock in zwei Routinen\\(R1: x.RLock $\to$ y.RLock, R2: y.RLock $\to$ x.RLock)} & Ja & Nein \\ \hline
    9.4 & \makecell[l]{Kein potentielles Deadlock mit RW-Lock in zwei Routinen\\(R1: x.Lock $\to$ y.RLock, R2: y.RLock $\to$ x.Lock)} & Ja & Nein \\ \hline
    9.5 & \makecell[l]{Kein potentielles Deadlock mit RW-Lock in zwei Routinen\\(R1: x.RLock $\to$ y.Lock, R2: y.RLock $\to$ x.RLock)} & Ja & Nein \\ \hline
    9.6 & \makecell[l]{Kein potentielles Deadlock mit RW-Lock in zwei Routinen\\(R1: x.Lock $\to$ y.RLock, R2: y.RLock $\to$ x.RLock)} & Nein & Nein \\ \hline
    10.1 & \makecell[l]{Kein Potentielles Deadlock, wegen Lock von RW-Locks\\als Gate-Locks.} & Ja & Nein \\ \hline
    10.2 & \makecell[l]{Potentielles Deadlock, da R-Lock von Deadlock nicht als\\Gate-Lock funktioniert.} & Ja & Ja \\ \hline
    11.1 & \makecell[l]{Doppeltes Locking von RW-Locks, welches zu Deadlock führt\\(Lock$\to$Lock, RLock$\to$Lock, Lock$\to$Rlock)} & Ja & Ja \\ \hline
    11.2 & \makecell[l]{Doppeltes Locking von RW-Locks, welches nicht zu einem\\Deadlock führt(RLock$\to$Rlock)} & Ja & Nein \\ \hline
\end{tabular}
\caption{Funktionale Analyse der Standartsituationen\\$^*$: sasha-s implementiert keine Try-Locks}
\label{Tab::Analyse:Functional.Standart}
\end{table}
Für RW-Locks gibt es in beiden Detektoren ein Implementierung. Allerdings unterscheidet
sich die Detektion von Deadlocks in sasha-s für RW-Locks nicht von der für 
normale Locks. Aus diesem Grund kommt es bei diesem Detektor zu false-positives,
wenn ein Zyklus in den Lock-Operationen aufgrund von RLock-Operationen nicht 
zu einem Deadlock führen kann. Deadlock-Go kann in vielen dieser Situationen 
eine false-positive Meldung verhindern (9.1-9.5), allerdings gibt es auch hier 
Situationen, in denen eine false-positive Meldung nicht verhindert werden kann (9.6).\\
Wie schon bei normalen Locks ist sasha-s auch bei RW-Locks nicht in der Lage 
zu erkennen, wenn zyklisches Locking, durch Gate-Locks nicht zu einem Deadlock 
führen kann, während dies für Deadlock-Go möglich ist (10.1). Es ist auch in der Lage 
zu erkennen, dass R-Locks nicht als Gat-Locks funktionieren. Da sasha-s allgemein 
nicht in der Lage ist Gate-Locks zu erkennen, wird dies automatische erkannt. (10.2).\\
Ähnliches gilt auch für doppeltes Locking. Sasha-s ist 
nicht in der Lage zu erkennen, wenn doppeltes Locking wegen R-Lock nicht auftreten 
können (11.2), erkennt aber doppeltes Locking allgemein, und damit auch, wenn 
es mit R-Locks zu doppeltem Locking kommt (11.1). Deadlock-Go kann beide Situationen
korrekt erkennen.
\\\\
Im folgenden sollen nun Beispielprogramme aus GoBench
betrachtet werden. Für Deadlock-Go wurden dabei alle Optionen aktiviert, um ein 
optimales Detektionsergebnis zu erhalten.
Die folgende Tabele \ref{Tab::Analyse:Functional.Example} gibt für jedes Programm an,
 ob es von den Detektoren erkannt wurde.
\begin{table}[H]
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{ID} & \textbf{Deadlock-Go} & \textbf{sasha-s} \\ \hline
Cockroach584 & Ja & Ja \\ \hline
Cockroach9935 & Ja & Ja \\ \hline
Cockroach6181 & Ja & Ja \\ \hline
Cockroach7504 & Ja & Ja \\ \hline
Cockroach10214 & Ja & Ja \\ \hline
Etcd5509 & Nein & Nein \\ \hline
Etcd6708 & Ja & Ja \\ \hline
Etcd10492 & Ja & Ja \\ \hline
Kubernetes13135 & Ja & Ja \\ \hline
Kubernetes30872 & Ja & Ja \\ \hline
Moby4951 & Ja & Ja \\ \hline
Moby7559 & Ja & Ja \\ \hline
Moby17176 & Nein & Nein \\ \hline
Moby36114 & Ja & Ja \\ \hline
Syncthing4829 & Ja & Ja \\ \hline
\end{tabular}
\caption{Funktionale Analyse der Beispielprogramme}
\label{Tab::Analyse:Functional.Example}
\end{table}
Beide Detektoren waren in der Lage die potentiellen Deadlocks in 13 der 15 
Beispielprogramme zu erkennen. Bei zwei der Programm war keiner der beiden Detektoren 
in der Lage, einen potentiellen Deadlock zu finden. Bei dieses beiden 
Programmen handelt es sich um Programme, bei denen es bei besonderen 
Abläufen dazu kommt, das vergessen wird Locks frei zu geben, was zu einem Deadlock 
führen kann. Da diese Pfade aber nur in sehr speziellen Situationen abgelaufen 
werden ist es verständlich, dass die Detektoren nicht in der Lage sind, diese 
zu erkennen.\\\\
Es ist erstaunlich, dass sasha-s gleich viele Probleme richtig erkannt hat, obwohl 
Deadlock-Go in den Standartproblemen in Tab. \ref{Tab::Analyse:Functional.Standart}
bessere Ergebnisse gezeigt hat. Dies lässt darauf schließen, dass solche 
Situationen, in denen Deadlock-Go besser abschneidet nicht sehr häufig 
in tatsächlichen Situationen auftreten. Es muss allerdings auch beachtet werden, 
dass es sich bei den betrachteten Beispielen um Situationen handelt, in denen
Deadlocks tatsächlich auftreten, wären Deadlock-Go vor allem bei der 
Verhinderung von false-positives besser abschneidet als sasha-s. Diese 
Situation kommen in dem Beispielen allerdings nicht vor.


\section{Zeitliche Analyse}
Im folgenden soll der Einfluss der Detektion auf die Laufzeit eines Programms 
für beide Detektoren betrachtet werden. Dafür werden die Laufzeiten der 
Standardprogramme aus Tab. \ref{Tab::Analyse:Functional.Standart} betrachtet, 
welche nicht zu einem tatsächlichen Deadlock führen und von keinem Detektor 
(fälschlicherweise) als solches erkannt wird. Außerdem werden keine Beispiele 
für Beispiele mit Try-Locks betrachtet, da diese von sasha-s nicht unterstützt werden.\\ 
Da die Laufzeit von der verwendeten Hardware, sowie anderen äußeren Faktoren 
abhängt, sollten diese Messwerte immer nur relativ zu den anderen Messungen 
in diesem Bericht, nicht aber als eigenständige, absolute Werte gesehen werden.\\ 
Für jedes dieser Programme 
wird in der folgenden Tabelle die Laufzeit ohne sowie mit Detektor angezeigt.
Für Deadlock-Go wird jeweils sowohl die Laufzeit der Programmausführung (ohne 
abschließende Detektion) und die Gesamtlaufzeit angegeben. Dabei wird auf verschiedene 
Weisen gemessen. Für die Messung ohne Detektor wird die Messung 1000 mal wiederholt
der Mittelwert angegeben. Dabei erhält man folgende Laufzeiten 
(normiert auf durchschnittliche Zeit pro Durchlauf):

\begin{table}[H]
    \centering
\begin{tabular}{|c|c|}
\hline
ID   & Laufzeit [$\mu$s]   \\ \hline
1.1  & $1.7$ \\ \hline
1.2  & $1.6$       \\ \hline
2    & $2.6$        \\ \hline
3    & $1.5$        \\ \hline
4    & $2.0$        \\ \hline
9.1  & $1.4$        \\ \hline
9.2  & $1.4$       \\ \hline
9.3  & $1.4$        \\ \hline
9.4  & $1.5$        \\ \hline
9.5  & $1.6$        \\ \hline
9.6  & $1.4$        \\ \hline
10.1 & $1.6$        \\ \hline
10.2 & $1.5$        \\ \hline
$\varnothing$ & $1.63$ \\ \hline 
\end{tabular}
\caption{Laufzeit der Programme ohne Detektor pro Durchlauf}
\end{table}
Für die Messung mit den Detektoren werden jeweils 
mehrere Messungen betrachtet. Für den Deadlock-Go Detektor werden jeweils 4
Messungen gemacht: Messung der Laufzeit von 1000 Durchläufen (mit und ohne 
periodische Detektion) ohne abschließend Detektion, Messung der Laufzeit der abschließenden Detektion nach 
einem Durchlauf und Messung der Laufzeit nach 1000 Durchläufen. Die Laufzeit
wir jeweils wieder normiert auf die durchschnittliche Zeit pro Durchlauf angegeben.
Für die Messungen wurde die Ausgabe des Warntextes deaktiviert.
Für die Zeit der abschließenden Detektion wird die Gesamtzeit angegeben.
\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|}
    \hline
    ID &
      \makecell{Laufzeit ohne\\periodischer\\Detektion [ms]} &
      \makecell{Laufzeit mit\\periodischer\\Detektion [ms]} &
      \makecell{Abschließende Detektion\\nach einem\\Durchlauf [ms]} &
      \makecell{Abschließende Detektion\\nach 1000\\Durchläufen [ms]} \\ \hline
    1.1  & 2.496 & 2.586 & 0.031 & 96.496  \\ \hline
    1.2  & 2.523 & 2.668 & 0.056 & 112.773  \\ \hline
    2    & 4.212 & 4.215 & 0.040 & 229.732  \\ \hline
    3    & 2.908 & 3.237 & 0.010 & 200.216  \\ \hline
    4    & 3.981 & 4.151 & 0.026 & 104.504   \\ \hline
    9.1  & 2.574 & 2.747 & 0.044 & 95.580  \\ \hline
    9.2  & 2.706 & 2.773 & 0.045 & 117.593  \\ \hline
    9.3  & 2.921 & 2.973 & 0.028 & 140.848  \\ \hline
    9.4  & 2.901 & 2.986 & 0.031 & 118.540  \\ \hline
    9.5  & 3.004 & 3.228 & 0.038 & 101.845  \\ \hline
    9.6  & 2.750 & 2.967 & 0.010 & 128.422  \\ \hline
    10.1 & 2.743 & 2.922 & 0.009 & 119.455  \\ \hline
    10.2 & 2.724 & 2.725 & 0.041 & 196.584 \\ \hline
    $\varnothing$ & 2.957 & 3.091 & 0.0315 & 135.583 \\ \hline
    \end{tabular}
    \caption{Laufzeit der Programme mit Deadlock-Go. Laufzeit Werte pro Durchlauf}
    \label{Kap::Analysis:Deadlock-Go}
\end{table}

Für sasha-s werden die Programme wieder 1000 mal durchlaufen und anschließend 
der Mittelwert pro Durchlauf betrachtet. Dabei erhält man folgende Werte.
\begin{table}[H]
    \centering
    \begin{tabular}{|l|l|}
    \hline
    ID   & Laufzeit [ms] \\ \hline
    1.1  & 12.782        \\ \hline
    1.2  & 8.687         \\ \hline
    2    & 12.696        \\ \hline
    3    & 18.451        \\ \hline
    4    & 7.953         \\ \hline
    9.1  & 8.621         \\ \hline
    9.2  & 11.566        \\ \hline
    9.3  & 8.583         \\ \hline
    9.4  & 12.169        \\ \hline
    9.5  & 9.219         \\ \hline
    9.6  & 13.545         \\ \hline
    10.1 & 7.737         \\ \hline
    10.2 & 9.184         \\ \hline
    $\varnothing$ & 10.861 \\ \hline
    \end{tabular}
    \caption{Laufzeit der Programme mit sasha-s. Laufzeit Werte pro Durchlauf}
    \label{tab:my-table}
\end{table}
Es ist sehr offensichtlich, dass die Programme mit den Detektoren eine 
signifikant längere Laufzeit haben. Während die Programme ohne Detektor im 
Schnitt eine Laufzeit von $1.63\mu\text{s}$ haben, haben sie mit sasha-s ein durchschnittliche
Laufzeit von $10.861$ ms und für Deadlock-Go mit periodischer Detektion $3.123$ ms - $138.674$ ms,
Es sollte beachtet werden, 
dass die Differenz zwischen der Laufzeit mit und ohne Detektor stark 
von der Anzahl der auf Locks ausgeführten Optionen ist. Da die hier verwendeten 
Beispielprogramme nahezu ausschließlich aus solchen Operationen bestehen, ist 
der Effekt besonders hoch.\\ \\
Wie die beiden Detektoren gegenseitig abschneiden hängst sehr stark von der 
Anzahl der betrachteten Routinen und Locks bzw. Dependencies ab. Während bei 
kleinen Programmen Deadlock-Go besser abschneidet, (vgl. Tab. \ref{Kap::Analysis:Deadlock-Go} mit 
Abschließende Detektion nach einem Durchlauf), schneidet bei großen Programmen 
mit vielen Routinen und Dependencies sasha-s deutlich besser ab (vgl. Tab \ref{Kap::Analysis:Deadlock-Go}
Abschließende Detektion nach 1000 Durchläufen). Dabei fällt besonders 
die abschließende Detektion ins Gewicht, welche sehr stark von der Anzahl der 
Dependencies und Routinen abhängt.\\
Beide Detektoren sind in der Lage, die Detektion zu deaktivieren, so dass die 
dann nur noch 
einen sehr geringe Verlängerung der Laufzeiten haben. Nachdem ein Programm 
zu Ende entwickelt wurde, und alle potentiellen Deadlock beseitigt wurden, 
kann die Detektion somit deaktiviert werden um die schnelleren Laufzeiten zu erreichen,
ohne dass der Detector aus dem Code entfernt werden muss.
 


